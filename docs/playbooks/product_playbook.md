# Product Playbook
## First Principles of Product Design

*"The ultimate goal of every product is to become one button."*

> **Meta-note:** This Playbook is itself a product â€” the **One-Button Product Builder**. 
> When you have a transformational result to deliver, this playbook turns it into a product.

### Result â‰  Feature

| Term | Definition | Focus |
|------|------------|-------|
| **Feature** | A capability the product has | What the product *does* |
| **Result** | A transformation the user receives | What the user *gets* |

Features are implementation. Results are value. This Playbook operates in **results**, not features.

---

# Part I: Philosophy â€” First Principles

## The Chain of Definitions

| Term | Definition |
|------|------------|
| **Product** | Any organized activity that **creates value** for another person |
| **Value** | Any change to better state of another person: **transformation** |
| **Transformation** | Transition from **Point A** (before) to **Point B** (after) |
| **Point A â†’ Point B** | The core of any product |

**Simplification:**
```
Product = Transformation
Transformation = Point A â†’ Point B
Therefore: Product = Point A â†’ Point B
```

---

## The Anatomy of a Screen

Every graphical interface consists of ONE SCREEN that can contain:

### Dimension 1: Data Output (Information Delivery)
Communicating something to the user:
- **Raw information** â€” Text, symbols, data
- **Infographics** â€” Information packaged for rapid comprehension
- **Formats** (complexity order): Symbol â†’ Icon â†’ Text â†’ Audio â†’ Video â†’ Interactive â†’ VR/AR

### Dimension 2: Data Input (Information Request)
Requesting something from the user:
- Form fields, selections, uploads
- Must be **justified** by the result it creates

### Dimension 3: Action (Magic Button)
A button that **creates a result** for the user:
- The core interface element
- Labeled with the result, not the action

### Dimension 4: Beauty (Aesthetic Harmony)
Raising user's internal harmony through aesthetic energy.

### Dimension 5: Relationships Between Elements
Elements can be:
- **Grouped** together
- **Encoded with logic** (if/then)
- **Positioned** to show interrelationship

### Dimension 6: Function
Any programmed logic (showing/hiding, calculations, API calls).

---

## The Master Parameter â€” Usability

**Usability** = How many transformations among system's possible transformations can be completed by a human interface user.

| More | â†’ Less Usability |
|------|------------------|
| Buttons | â†’ Lower usability |
| Steps | â†’ Lower usability |
| Complex communication | â†’ Lower usability |

| Fewer | â†’ Higher Usability |
|-------|-------------------|
| Buttons | â†’ Higher usability |
| Steps | â†’ Higher usability |
| Sub-results to result | â†’ Higher usability |

### The Limit: One Button

**The evolutionary goal of every product is to become one button.**

This is the limit. The user must express *some* intention to receive a result. In graphical interfaces, that's pressing a button. Simpler would only be thought control.

---

## The Structure of a User Journey

**User Journey** = series of screens leading to transformation.

### First Screen (of entire journey)
- States **what result we will create** for the user
- Contains the **Magic Button**: "Start"

### Last Screen (of entire journey)
- Shows **the result that was created**
- Highlights **what we accomplished**
- Offers the **next step**: deeper engagement, adjacent result, or paid offering

### Sub-Results
Complex journeys require intermediate results (sub-results), each with:
- **Start screen**: Promise + Magic Button
- **End screen**: Result + Value + Next Step

**Fractal principle:** Sub-results can nest infinitely, but each level must remain atomic and purposeful.

---

# Part II: Execution Workflow

*Follow this sequence. Don't skip.*

```
PHASE 1: MASTER RESULT
1. State the Master Result
2. Design First Screen (promise + Magic Button)
3. Design Last Screen (result + celebration + next step)

PHASE 2: SUB-RESULTS
4. List Sub-Results that lead to Master Result
5. Sequence them
6. Define Start/End screens for each

PHASE 3: NESTED LAYERS
7. Go deeper into each Sub-Result
8. Repeat until atomic screens
9. Stop when no more nesting needed

PHASE 4: SCREEN DETAILS
10. For each screen: Data Output, Data Input, Magic Button, Navigation

PHASE 5: ROAST & ITERATE
11-13. Critique, fix, repeat until solid

PHASE 6: EXTENSION MODULES
14-18. Artifacts, Emotional States, Completion, Skip Paths, Bridges

PHASE 7: WIREFRAMES
19-21. ASCII sketches, navigation map, transitions

PHASE 8: WIREFRAME ROAST
22-24. Roast wireframes (3 cycles), synthesize, refine

PHASE 9: BUILD
25-27. Tasks, code, verify
```

---

## Phase 1: Define the Master Result

### Step 1: State the Master Result

**Master Result of Product:**
> "From [Point A] to [Point B]"

Example: "From 'I don't know my genius' to 'I have a clear Zone of Genius statement'"

### Step 2: Design First Screen

| Element | Content |
|---------|---------|
| **Headline** | Promise of transformation |
| **Subtext** | What they'll get |
| **Magic Button** | "Start [Journey Name]" |

### Step 3: Design Last Screen

| Element | Content |
|---------|---------|
| **Result Display** | The transformation achieved |
| **Celebration** | "You did it!" moment |
| **Next Step** | Where to go from here |

---

## Phase 2: Break into Sub-Results

### Step 4: List Sub-Results

What intermediate results lead to Master Result?

| # | Sub-Result | Start Screen | End Screen |
|---|------------|--------------|------------|
| 1 | | | |
| 2 | | | |
| 3 | | | |

### Step 5: Sequence Sub-Results

Each builds on the previous. Order matters.

### Step 6: Define Start/End for Each

For each sub-result:
- **Start**: Promise + Magic Button
- **End**: Result + Value + Next Step

---

## Phase 3: Nested Layers (Go Deeper)

For each Sub-Result, ask: "Can this be done in one screen?"

If NO â†’ Break into smaller sub-results.
If YES â†’ Mark as atomic.

Repeat until all screens are atomic (no further breakdown possible).

---

## Phase 4: Screen Details

For each screen, define:

| Aspect | Details |
|--------|---------|
| **Data Output** | What user sees/learns |
| **Data Input** | What user provides (if any) |
| **Magic Button** | Label with result, not action |
| **Navigation** | Back, Skip, Progress indicator |

### Screen Communication Template

Each screen should communicate through Three Dan Tians:

| Dimension | Question | Purpose |
|-----------|----------|---------|
| ðŸ«€ **HEART** | "What just happened?" | Core essence of the result |
| ðŸ§  **MIND** | "What does this mean for you?" | Significance, value |
| ðŸ”¥ **GUT** | "What's the next step?" | Implication, action |

---

## Phase 5: Roast & Iterate

### Step 11: Roast the Spec

| Category | Questions |
|----------|-----------|
| **Consistency** | Same voice throughout? |
| **Usability** | Can steps be reduced? |
| **Clarity** | Any confusion points? |
| **Magic Buttons** | All labeled with results? |
| **Flow** | Natural progression? |

### Step 12: Fix What the Roast Revealed

Update spec based on critique.

### Step 13: Repeat Until Solid

Minimum 2-3 roast cycles.

---

## Phase 6: Extension Modules

### Module 1: Artifacts

What tangible thing does user RECEIVE at each stage?

| Stage | Artifact |
|-------|----------|
| [Sub-result 1] | [What they get] |
| [Sub-result 2] | [What they get] |
| ... | ... |

### Module 2: Emotional States

| After | User Feels | Next Screen Should |
|-------|------------|-------------------|
| [Stage] | [Emotion] | [How to honor it] |

**Question:** "How does the user *feel* right now, and does the next screen honor that?"

### Module 3: Completion Signals

| Stage | âœ… Done When | How We Celebrate |
|-------|-------------|------------------|
| [Stage] | [Condition] | [Celebration] |

### Module 4: Skip Paths

| If Skipped | Consequence | Minimum Viable |
|------------|-------------|----------------|
| [Stage] | [What breaks] | [Minimum needed] |

### Module 5: Bridges

How does this product connect to other products/modules?

| From | To | Bridge |
|------|-----|--------|
| [This product] | [Next product] | [Transition] |

---

## Phase 7: Wireframes

### Step 19: ASCII Wireframes

Create simple ASCII sketches for key screens:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    [HEADER]                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                     â”‚
â”‚  [Main content area]                                â”‚
â”‚                                                     â”‚
â”‚       [ Magic Button â†’ ]                            â”‚
â”‚                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Step 20: Navigation Flow Map

```
[Screen 1] â†’ [Screen 2] â†’ [Screen 3] â†’ [End]
     â†“            â†“
  [Skip]      [Back]
```

### Step 21: Transitions

Define how screens connect and animate.

---

## Phase 8: Wireframe Roast

### Step 22: Three Roast Cycles

Cycle 1: Usability check
Cycle 2: Visual hierarchy check
Cycle 3: Edge case check

### Step 23: Synthesize Feedback

Compile all issues found.

### Step 24: Refine

Update wireframes based on roast.

---

## Phase 9: Build & Verify

### Step 25: Break into Tasks

Each screen â†’ implementation task.

### Step 26: Code

Build according to spec.

### Step 27: Verify

Test against spec:
- [ ] All screens match spec
- [ ] All Magic Buttons work
- [ ] All navigation works
- [ ] Emotional states honored

---

# Part III: Quick Reference

## AI Prompt Template

When using AI to build, provide:

```
MASTER RESULT: [What the user gets]

SUB-RESULTS:
1. [First sub-result]
2. [Second sub-result]
3. [Third sub-result]

FOR EACH SUB-RESULT:
- Start screen: [Promise + button text]
- Input needed: [What + why]
- End screen: [Result shown + value + next step]

NAVIGATION: [Which elements needed]

STYLE: [Harmony/beauty notes]
```

AI handles the rest.

---

## The Meta-Insight

> What we have just done is define **the deepest principles of product design** â€” the foundation on which all interfaces are built.

From these first principles, we can:
- Add any functionality
- Play with any parameters
- Assemble any screen, any user journey

**Like LEGO blocks, these primitives combine into anything.**

This is product building: Describe what you want, structured by these principles, and execute.

---

# Part IV: The Recursive Insight

**This Playbook is a product.**

The Product Playbook can create any product... 
The Product Playbook has Input â†’ Process â†’ Output â†’ Transformation...
Therefore: You can run Product Playbook on itself.

### The Complete Stack:

```
L1: Zone of Genius discovered
L2: ZoG â†’ productized via Product Playbook
L3: Product â†’ marketed via Marketing Playbook  
L4: Marketing â†’ distributed via Distribution Playbook
L5: Distribution â†’ attracts mission-aligned people
L6: People â†’ form integrative working group
L7: Working group â†’ evolves the product
L8: Evolution â†’ new cycle begins
```

This is **self-organizing infrastructure for mission manifestation**.

---

## Related Documents

- [marketing_playbook.md](./marketing_playbook.md) â€” Marketing layer (values-based messaging)
- [distribution_playbook.md](./distribution_playbook.md) â€” Distribution layer (channels, virality)
- [pain_theory_playbook.md](./pain_theory_playbook.md) â€” ICP pain analysis

---

*Codified: January 2026*
*The ultimate goal of every product is to become one button.*
